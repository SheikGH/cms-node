// === CLEAN ARCHITECTURE - NODE + EXPRESS + MONGODB + JWT + RBAC + REDIS + WEBSOCKET ===

// Folder Structure:
// src/
// ├── api/                 => Controllers, Routes
// ├── application/         => DTOs, Interfaces
// ├── config/              => DB, Cache, WebSocket Config
// ├── core/                => Models
// ├── infrastructure/      => Repositories
// ├── services/            => Business Logic
// ├── middleware/          => Middleware
// └── app.js, server.js

// STEP 1: package.json dependencies
// npm install express mongoose express-validator cors dotenv jsonwebtoken bcryptjs redis socket.io

// File: src/config/db.config.js
const mongoose = require('mongoose');
require('dotenv').config();

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log('MongoDB connected');
  } catch (err) {
    console.error(err);
    process.exit(1);
  }
};

module.exports = connectDB;

// File: src/config/redis.config.js
const { createClient } = require('redis');
require('dotenv').config();

const redisClient = createClient({
  url: process.env.REDIS_URL
});

redisClient.on('error', (err) => console.error('Redis Client Error', err));

(async () => {
  await redisClient.connect();
  console.log('Redis connected');
})();

module.exports = redisClient;

// File: src/config/socket.config.js
let io;

const initSocket = (server) => {
  const { Server } = require('socket.io');
  io = new Server(server, {
    cors: {
      origin: '*',
    },
  });
  console.log('Socket.IO initialized');

  io.on('connection', (socket) => {
    console.log('Client connected:', socket.id);

    socket.on('disconnect', () => {
      console.log('Client disconnected:', socket.id);
    });
  });
};

const getIO = () => {
  if (!io) {
    throw new Error('Socket.io not initialized');
  }
  return io;
};

module.exports = { initSocket, getIO };

// File: src/core/models/customer.model.js
const mongoose = require('mongoose');

const customerSchema = new mongoose.Schema({
  customerId: { type: String, required: true, unique: true },
  firstName: { type: String, required: true },
  lastName: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  phone: { type: String },
  address: { type: String },
  password: { type: String, required: true },
  role: { type: String, enum: ['user', 'admin'], default: 'user' },
}, { timestamps: true });

module.exports = mongoose.model('Customer', customerSchema);

// File: src/application/dto/customer.dto.js
class CustomerDTO {
  constructor({ customerId, firstName, lastName, email, phone, address, password, role }) {
    this.customerId = customerId;
    this.firstName = firstName;
    this.lastName = lastName;
    this.email = email;
    this.phone = phone;
    this.address = address;
    this.password = password;
    this.role = role;
  }
}

module.exports = CustomerDTO;

// File: src/infrastructure/repositories/customer.repository.js
const Customer = require('../../core/models/customer.model');
const redisClient = require('../../config/redis.config');
const { getIO } = require('../../config/socket.config');

class CustomerRepository {
  async create(data) {
    const created = await Customer.create(data);
    await redisClient.del('customers');
    getIO().emit('customer:created', created);
    return created;
  }

  async findAll() {
    const cached = await redisClient.get('customers');
    if (cached) return JSON.parse(cached);
    const customers = await Customer.find();
    await redisClient.set('customers', JSON.stringify(customers));
    return customers;
  }

  async findById(id) {
    const cacheKey = `customer:${id}`;
    const cached = await redisClient.get(cacheKey);
    if (cached) return JSON.parse(cached);
    const customer = await Customer.findById(id);
    if (customer) await redisClient.set(cacheKey, JSON.stringify(customer));
    return customer;
  }

  async findByEmail(email) {
    return await Customer.findOne({ email });
  }

  async update(id, data) {
    const updated = await Customer.findByIdAndUpdate(id, data, { new: true });
    await redisClient.del('customers');
    await redisClient.del(`customer:${id}`);
    getIO().emit('customer:updated', updated);
    return updated;
  }

  async delete(id) {
    const deleted = await Customer.findByIdAndDelete(id);
    await redisClient.del('customers');
    await redisClient.del(`customer:${id}`);
    getIO().emit('customer:deleted', { id });
    return deleted;
  }
}

module.exports = new CustomerRepository();

// File: src/app.js
const express = require('express');
const cors = require('cors');
const customerRoutes = require('./api/routes/customer.routes');
const connectDB = require('./config/db.config');
const errorMiddleware = require('./middleware/error.middleware');
require('./config/redis.config');

const app = express();
connectDB();

app.use(cors());
app.use(express.json());

app.use('/api/customers', customerRoutes);
app.use(errorMiddleware);

module.exports = app;

// File: src/server.js
const http = require('http');
const app = require('./app');
const { initSocket } = require('./config/socket.config');

const PORT = process.env.PORT || 5000;
const server = http.createServer(app);

initSocket(server);

server.listen(PORT, () => console.log(`Server running on port ${PORT}`));

// File: .env
// MONGO_URI=mongodb://localhost:27017/yourdb
// JWT_SECRET=your_jwt_secret
// REDIS_URL=redis://localhost:6379
